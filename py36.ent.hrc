<?xml version="1.0" encoding="iso-8859-1"?>
<type name="python36">
    <region name="Error" parent="def:Error"/>
    <region name="Deprecated" parent="def:Debug" description="Show deprecated Python feature that will be removed in a later version"/>
    <region name="PEP8" parent="def:Debug" description="PEP 8 -- Style Guide for Python Code"/>

    <region name="Constant" parent="def:Constant"/>
    <region name="BooleanConstant" parent="def:BooleanConstant"/>

    <region name="PairStart" parent="def:PairStart" description="Paired struct start"/>
    <region name="PairEnd"  parent="def:PairEnd" description="Paired struct end"/>
    <region name="Keyword" parent="def:Keyword"/>
    <region name="Parameter" parent="def:Parameter" description="Parameter declaration"/>
    <region name="Operator" parent="def:Operator" description="Symbolic or Literal Operator"/>
    <region name="Delimiter" parent="def:Symbol"/>
    <region name="Directive" parent="def:Directive" description="Compiler/Preprocessor directive"/>
    <region name="DirectiveContent" parent="def:DirectiveContent" description="Internal directive text"/>
    <region name="DirectiveEdge"    parent="def:DirectiveEdge" description="Directive edges"/>

    <entity name="code_end" value="\M(^\.\. code|%def:neverMatch;)"/>

	&py36COMMENT;
	&py36NUMBER;
	&py36NAME;
	&py36STRING;
	&py36SMALL;
	&py36COMPOUND;

	<scheme name="Error">
		<regexp match="/\S/" region="Error" priority="low"/>
	</scheme>

	<scheme name="python36">
      	<inherit scheme="Python_File_Header"/>
      	<inherit scheme="code_body"/>
	</scheme>

    <scheme name="Python_File_Header">
      	<inherit scheme="shebang"/>
      	<inherit scheme="File_Encoding"/>
    </scheme>

<!--Shebang (Unix): https://en.wikipedia.org/wiki/Shebang_%28Unix%29-->
<!-- PEP 397: Python launcher for Windows: https://www.python.org/dev/peps/pep-0397/-->
    <scheme name="shebang">
      	<block start="/(#!)\s*(\S*)\s*(python(3(\.\d+(-32)?)?)?).*/" end="/%code_end;/" scheme="File_Encoding" region00="Directive" region01="DirectiveEdge" region03="DirectiveContent" content-priority="low"/>
    </scheme>

<!--Encoding declarations: https://docs.python.org/3/reference/lexical_analysis.html#encoding-declarations-->
    <scheme name="File_Encoding">
      <block start="/^\s*(#).*(coding)([=:])\s*(ascii|utf-8).*$/" end="/%code_end;/" scheme="code_body" region00="LineComment" region01="CommentEdge" region02="Keyword" region03="Delimiter" region04="Parameter" content-priority="low"/>
    </scheme>

	<scheme name="code_body">
		<block start="//" end="//" scheme="single_input"/>
	</scheme>

<!-- single_input: NEWLINE | simple_stmt | compound_stmt NEWLINE -->
	<scheme name="single_input">
		<inherit scheme="COMMENT"/>
		<inherit scheme="compound_stmt"/>
      	<inherit scheme="simple_stmt"/>
		<inherit scheme="Error"/>
	</scheme>

<!-- stmt: simple_stmt | compound_stmt -->
	<scheme name="stmt">
		<inherit scheme="COMMENT"/>
		<inherit scheme="compound_stmt"/>
		<inherit scheme="simple_stmt"/>
	</scheme>

<!-- simple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE -->
    <scheme name="simple_stmt">
		<inherit scheme="COMMENT"/>
      	<block start="/\s*(;)\s*/" end="/$/" scheme="small_stmt" region01="Delimiter"/>
      	<inherit scheme="small_stmt"/>
    </scheme>

<!-- expr_stmt: testlist_star_expr (annassign | augassign (yield_expr|testlist) |
                     ('=' (yield_expr|testlist_star_expr))*) -->
    <scheme name="expr_stmt">
    	<inherit scheme="test"/>
    </scheme>

<!-- PEP 308 : Conditional Expressions: https://www.python.org/dev/peps/pep-0308/ -->
<!--test: or_test ['if' or_test 'else' test] | lambdef-->
    <scheme name="test">
		<inherit scheme="expr"/>
    </scheme>

<!-- star_expr: '*' expr -->
	<scheme name="star_expr">
		<block start="/(\*)/" end="//" scheme="expr" region01="Operator"/>
	</scheme>

	<scheme name="test_star_expr">
		<inherit scheme="star_expr"/>
		<inherit scheme="test"/>
	</scheme>

<!--expr: xor_expr ('|' xor_expr)*-->
    <scheme name="expr">
		<inherit scheme="atom_expr"/>
    </scheme>

<!--atom_expr: [AWAIT] atom trailer*-->
	<scheme name="atom_expr">
		<block start="/~\s*/" end="//" scheme="atom"/>
		<inherit scheme="trailer"/>
	</scheme>

<!--atom:
(
	'(' [yield_expr|testlist_comp] ')'
	|
	'[' [testlist_comp] ']'
	|
	'{' [dictorsetmaker] '}'
	|
	NAME | NUMBER | STRING+ | '...'
)
-->
    <scheme name="atom">
		<block start="/~(?{PairStart}(\())/" end="/(?{PairEnd}\))/" scheme="yield_expr_testlist_comp" region01="Delimiter" region10="Delimiter"/>
		<inherit scheme="NUMBER"/>
		<inherit scheme="STRING"/>
		<inherit scheme="Constants"/>
		<inherit scheme="NAME"/>
    </scheme>

    <scheme name="Constants">
    	<regexp match="/\.\.\.|Ellipsis|None|__debug__|NotImplemented/" region="Constant"/>
    	<regexp match="/True|False/" region="BooleanConstant"/>
    </scheme>

	<scheme name="yield_expr_testlist_comp">
		<inherit scheme="yield_expr"/>
		<inherit scheme="test"/>
  	</scheme>

<!--trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME-->
	<scheme name="trailer">
		<block start="/\\$/" end="/^\s*/" scheme="def:empty"/>
		<block start="/\.\b/" end="//" scheme="NAME" region00="Delimiter"/>
		<block start="/\s*(?{PairStart}(\())/" end="/(?{PairEnd}\))/" scheme="arglist" region01="Delimiter" region10="Delimiter"/>
		<block start="/\s*(?{PairStart}(\[))/" end="/(?{PairEnd}\])/" scheme="subscriptlist" region01="Delimiter" region10="Delimiter"/>
	</scheme>

	<scheme name="arglist">
		<block start="/\M(&quot;)/" end="/\M(&quot;|\))/" scheme="STRING"/>
		<inherit scheme="test"/>
		<inherit scheme="Error"/>
	</scheme>

<!--subscriptlist: subscript (',' subscript)* [',']-->
	<scheme name="subscriptlist">
		<inherit scheme="test"/>
		<inherit scheme="Error"/>
	</scheme>

<!--testlist: test (',' test)* [',']-->
    <scheme name="testlist">
		<block start="/\s*(,)\s*/" end="//" scheme="test" region01="Delimiter"/>
      	<inherit scheme="test"/>
    </scheme>

<!-- yield_expr: 'yield' [yield_arg] -->
    <scheme name="yield_expr">
      	<block start="/(yield)\s*/" end="//" scheme="yield_arg" region01="Keyword"/>
    </scheme>

<!-- yield_arg: 'from' test | testlist -->
    <scheme name="yield_arg">
      	<block start="/~(from)\s*/" end="//" scheme="test" region01="Keyword"/>
      	<inherit scheme="testlist"/>
    </scheme>
</type>
