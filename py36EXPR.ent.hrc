<!-- expr_stmt:
testlist_star_expr
(
	annassign
	|
	augassign
		(
			yield_expr
			|
			testlist
		)
	|
	(
		'='
		(
			yield_expr
			|
			testlist_star_expr
		)
	)*
)
-->
<scheme name="expr_stmt">
	<block start="/(=)/" end="//" scheme="testlist_star_expr" region01="Delimiter"/>
	<inherit scheme="augassign"/>
	<inherit scheme="annassign"/>
	<inherit scheme="testlist_star_expr"/>
	<!--<inherit scheme="yield_expr"/>
	<inherit scheme="testlist"/>-->
</scheme>

<!--annassign: ':' test ['=' test]-->
<scheme name="annassign">
	<block start="/(:)\s*/" end="//" scheme="annassign_body" region01="Delimiter"/>
</scheme>

<scheme name="annassign_body">
	<block start="/\s*(=)\s*/" end="//" scheme="test" region01="Delimiter"/>
	<inherit scheme="test"/>
</scheme>

<!-- testlist_star_expr: (test|star_expr) (',' (test|star_expr))* [','] -->
<scheme name="testlist_star_expr">
	<block start="/\s*(,)\s*/" end="//" scheme="testlist_star_expr" region01="Delimiter"/>
	<inherit scheme="star_expr"/>
	<inherit scheme="test"/>
</scheme>

<!--augassign: ('+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//=')-->
<scheme name="augassign">
	<block start="/\s*([+-*@/%&amp;|^]|&lt;&lt;|>>|\*\*|//)(=)\s*/" end="//" scheme="testlist" region01="Operator" region02="Delimiter"/>
</scheme>

<!-- PEP 308 : Conditional Expressions: https://www.python.org/dev/peps/pep-0308/ -->
<!-- test: or_test ['if' or_test 'else' test] | lambdef -->
<scheme name="test">
	<block start="/(if)/" end="//" scheme="if_body" region01="Keyword"/>
	<inherit scheme="lambdef"/>
	<inherit scheme="or_test"/>
</scheme>

<scheme name="if_body">
	<block start="/~(if)?#2/" end="/\Melse/" scheme="or_test" region01="Keyword"/>
	<block start="/(else)/" end="//" scheme="test" region01="Keyword"/>
</scheme>

<!-- test_nocond: or_test | lambdef_nocond -->
<scheme name="test_nocond">
	<inherit scheme="lambdef_nocond"/>
	<inherit scheme="or_test"/>
</scheme>

<!-- lambdef: 'lambda' [varargslist] ':' test -->
<scheme name="lambdef">
	<block start="/(lambda)/" end="//" scheme="lambdef_body" region01="Keyword"/>
</scheme>

<scheme name="lambdef_body">
	<block start="/~(lambda)?#6/" end="/\M:/" scheme="varargslist" region01="Keyword"/>
	<block start="/(:)/" end="//" scheme="test" region01="Delimiter"/>
</scheme>

<!-- lambdef_nocond: 'lambda' [varargslist] ':' test_nocond -->
<scheme name="lambdef_nocond">
	<block start="/(lambda)/" end="//" scheme="lambdef_nocond_body" region01="Keyword"/>
</scheme>

<scheme name="lambdef_nocond_body">
	<block start="/~(lambda)?#6/" end="/\M:/" scheme="varargslist" region01="Keyword"/>
	<block start="/(:)/" end="//" scheme="test_nocond" region01="Delimiter"/>
</scheme>

<!--varargslist:
(
	vfpdef ['=' test] (',' vfpdef ['=' test])* [',' [ '*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]] | '**' vfpdef [',']]]
  	|
  	'*' [vfpdef] (',' vfpdef ['=' test])* [',' ['**' vfpdef [',']]]
  	|
  	'**' vfpdef [',']
)
-->
<scheme name="varargslist">
	<block start="/\s*(\*\*)\s*/" end="//" scheme="vfpdef" region01="Operator"/>
	<block start="/\s*(\*)\s*/" end="//" scheme="vfpdef" region01="Operator"/>
	<block start="/\s*(=)\s*/" end="//" scheme="test" region01="Delimiter"/>
	<block start="/\s*(,)\s*/" end="//" scheme="varargslist" region01="Delimiter"/>
	<inherit scheme="vfpdef"/>
</scheme>

<!--vfpdef: NAME-->
<scheme name="vfpdef">
	<inherit scheme="NAME"/>
</scheme>

<!-- or_test: and_test ('or' and_test)* -->
<scheme name="or_test">
	<inherit scheme="expr"/>
</scheme>

<!-- star_expr: '*' expr -->
<scheme name="star_expr">
	<block start="/(\*)/" end="//" scheme="expr" region01="Operator"/>
</scheme>

<scheme name="test_star_expr">
	<inherit scheme="star_expr"/>
	<inherit scheme="test"/>
</scheme>

<!-- expr: xor_expr ('|' xor_expr)* -->
<scheme name="expr">
	<inherit scheme="atom_expr"/>
</scheme>

<!-- atom_expr: [AWAIT] atom trailer* -->
<scheme name="atom_expr">
	<block start="/~\s*/" end="//" scheme="atom"/>
	<inherit scheme="trailer"/>
</scheme>

<!-- atom:
(
	'(' [yield_expr|testlist_comp] ')'
	|
	'[' [testlist_comp] ']'
	|
	'{' [dictorsetmaker] '}'
	|
	NAME | NUMBER | STRING+ | '...'
)
-->
<scheme name="atom">
	<block start="/~(?{PairStart}(\())/" end="/(?{PairEnd}\))/" scheme="yield_expr_testlist_comp" region01="Delimiter" region10="Delimiter"/>
	<block start="/~(?{PairStart}(\[))/" end="/(?{PairEnd}\])/" scheme="testlist_comp" region01="Delimiter" region10="Delimiter"/>
	<inherit scheme="NUMBER"/>
	<inherit scheme="STRING"/>
	<inherit scheme="Constants"/>
	<inherit scheme="NAME"/>
</scheme>

<scheme name="Constants">
	<regexp match="/\.\.\.|Ellipsis|None|__debug__|NotImplemented/" region="Constant"/>
	<regexp match="/True|False/" region="BooleanConstant"/>
</scheme>

<!-- testlist_comp: (test|star_expr) ( comp_for | (',' (test|star_expr))* [','] ) -->
<scheme name="testlist_comp">
	<block start="/\s*(,)\s*/" end="//" scheme="test_star_expr" region01="Delimiter"/>
	<inherit scheme="comp_for"/>
	<inherit scheme="test_star_expr"/>
</scheme>

<scheme name="yield_expr_testlist_comp">
	<inherit scheme="STRINGS"/>
	<inherit scheme="yield_expr"/>
	<inherit scheme="testlist_comp"/>
</scheme>

<!-- trailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME -->
<scheme name="trailer">
	<block start="/\\$/" end="/^\s*/" scheme="def:empty"/>
	<block start="/\.\b/" end="//" scheme="NAME" region00="Delimiter"/>
	<block start="/\s*(?{PairStart}(\())/" end="/(?{PairEnd}\))/" scheme="arglist" region01="Delimiter" region10="Delimiter"/>
	<block start="/\s*(?{PairStart}(\[))/" end="/(?{PairEnd}\])/" scheme="subscriptlist" region01="Delimiter" region10="Delimiter"/>
</scheme>

<!-- subscriptlist: subscript (',' subscript)* [','] -->
<scheme name="subscriptlist">
	<inherit scheme="test"/>
	<inherit scheme="Error"/>
</scheme>

<!-- exprlist: (expr|star_expr) (',' (expr|star_expr))* [','] -->
<scheme name="exprlist">
	<block start="/\s*(,)\s*/" end="//" scheme="exprlist" region01="Delimiter"/>
	<inherit scheme="star_expr"/>
	<inherit scheme="expr"/>
</scheme>

<!-- testlist: test (',' test)* [','] -->
<scheme name="testlist">
	<block start="/\s*(,)\s*/" end="//" scheme="test" region01="Delimiter"/>
	<inherit scheme="test"/>
</scheme>

<!-- comp_iter: comp_for | comp_if -->
<scheme name="comp_iter">
	<inherit scheme="comp_for"/>
	<inherit scheme="comp_if"/>
</scheme>

<!-- comp_for: [ASYNC] 'for' exprlist 'in' or_test [comp_iter] -->
<scheme name="comp_for">
	<block start="/\s*(for)/" end="//" scheme="comp_for_body" region01="Keyword"/>
</scheme>

<scheme name="comp_for_body">
	<block start="/~(for)?#3/" end="/\s*\Min/" scheme="exprlist"/>
	<block start="/(in)\s*/" end="//" scheme="or_test" region01="Keyword"/>
	<inherit scheme="comp_iter"/>
</scheme>

<!-- comp_if: 'if' test_nocond [comp_iter] -->
<scheme name="comp_if">
	<block start="/\s*(if)/" end="//" scheme="comp_if_body" region01="Keyword"/>
</scheme>

<scheme name="comp_if_body">
	<block start="/~(if)?#2\s*/" end="//" scheme="test_nocond"/>
	<inherit scheme="comp_iter"/>
</scheme>

<!-- yield_expr: 'yield' [yield_arg] -->
<scheme name="yield_expr">
	<block start="/(yield)\s*/" end="//" scheme="yield_arg" region01="Keyword"/>
</scheme>

<!-- yield_arg: 'from' test | testlist -->
<scheme name="yield_arg">
	<block start="/~(from)\s*/" end="//" scheme="test" region01="Keyword"/>
	<inherit scheme="testlist"/>
</scheme>
